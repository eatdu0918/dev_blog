---
title: '오버라이드(Override)의 개념과 Java vs JavaScript의 차이점'
date: '2026-02-22'
categories: ['Programming', 'Java', 'JavaScript']
---

# 오버라이드(Override)의 개념과 Java vs JavaScript의 차이점

객체 지향 프로그래밍(OOP)을 공부하다 보면 가장 많이 접하게 되는 개념 중 하나가 바로 **오버라이드(Override)**입니다. 여러 언어에서 다형성(Polymorphism)을 구현하는 핵심적인 방법으로 사용되지만, 언어의 특성에 따라 그 동작 방식이나 규칙에 차이가 있습니다. 

이번 포스팅에서는 오버라이드의 기본 개념을 짚어보고, 대중적인 언어인 **Java**와 **JavaScript**에서 오버라이드가 어떻게 다르게 동작하는지 비교해 보겠습니다.

---

## 1. 오버라이드(Override)란?

**오버라이드(Override)**는 객체 지향 언어에서 상속 관계에 있는 클래스 간에 발생하는 특징입니다. **부모 클래스(상위 클래스)가 가지고 있는 메서드를 자식 클래스(하위 클래스)가 자신의 필요에 맞게 "재정의"하여 사용하는 것**을 의미합니다.

- **기본 목적**: 부모가 제공하는 기본 동작을 무시하고(덮어쓰고), 자식 객체에 맞는 새로운 동작을 정의하기 위함입니다.
- **다형성 구현**: 동일한 메서드 호출이 객체의 실제 타입에 따라 다르게 동작하도록 만듭니다.

쉽게 말해, 부모님이 물려주신 스마트폰(부모 메서드)의 배경화면을 나만의 스타일로 바꾸는 것(자식의 재정의)과 같습니다.

---

## 2. Java에서의 오버라이드

Java는 **정적 타입(Static Type)**을 가지며 클래스 기반의 객체 지향 언어입니다. 그렇기 때문에 오버라이딩에 대한 규칙이 매우 엄격합니다.

### 2.1. Java 오버라이드 규칙
1. **메서드 시그니처가 완벽히 동일해야 함**: 메서드 이름, 매개변수의 개수와 타입, 리턴 타입이 부모 클래스의 메서드와 정확히 일치해야 합니다. (단, 리턴 타입은 부모 타입의 하위 타입으로 변경 가능 - 공변 반환 타입)
2. **접근 제어자**: 부모 클래스의 메서드보다 좁은 범위로 접근 제어자를 변경할 수 없습니다. (예: `protected`를 `private`으로 변경 불가)
3. **`@Override` 애노테이션**: 컴파일러에게 이 메서드가 오버라이딩된 것임을 명시적으로 알려주어, 실수로 메서드 이름을 틀리게 적는 등의 에러를 컴파일 타임에 잡아줍니다.

### 2.2. Java 예시 코드

```java
// 부모 클래스
class Animal {
    public void makeSound() {
        System.out.println("동물이 빈다.");
    }

    // 오버로딩 예시 (이름은 같고 매개변수만 다름)
    public void makeSound(int count) {
        for(int i = 0; i < count; i++) {
            System.out.println("동물이 웁니다.");
        }
    }
}

// 자식 클래스
class Dog extends Animal {
    // 부모 메서드 오버라이딩
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
    
    // 에러 발생 예시: 오버라이딩 시그니처 불일치시 컴파일 에러
    // @Override
    // public void makeSound(String sound) { ... }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound(); // 출력: 멍멍! (다형성 작용)
    }
}
```

Java에서는 "같은 이름"의 메서드라도 매개변수가 다르면 **오버로딩(Overloading)**으로 취급되어 완전히 다른 메서드로 인식됩니다. 따라서 오버라이딩을 할 때는 시그니처를 정확히 맞추는 것이 핵심입니다.

---

## 3. JavaScript에서의 오버라이드

JavaScript는 **동적 타입(Dynamic Type)** 언어이며, 프로토타입(Prototype) 기반의 객체 지향을 지원합니다. (ES6부터 `class` 키워드를 지원하지만, 내부적으로는 여전히 프로토타입으로 동작합니다.) 따라서 Java와 비교했을 때 규칙이 매우 느슨합니다.

### 3.1. JavaScript 오버라이드 특징
1. **메서드 이름만 같으면 무조건 오버라이딩 됨**: JavaScript에는 매개변수의 타입이나 개수를 강제하는 기능(오버로딩)이 없습니다. 자식 클래스에서 같은 이름의 메서드를 만들기만 하면, 프로토타입 체인에 의해 부모의 메서드가 덮어씌워집니다.
2. **매개변수 불일치 허용**: 부모 메서드는 매개변수를 0개 받는데, 자식 메서드는 2개를 받는 식으로 작성해도 문법적 에러가 발생하지 않습니다.
3. **`super` 키워드 제공**: 오버라이딩 한 후에도 부모 클래스의 원래 메서드를 호출하고 싶을 때는 `super.메서드명()`을 사용할 수 있습니다.

### 3.2. JavaScript 예시 코드

```javascript
// 부모 클래스
class Animal {
  makeSound(volume) {
    console.log(`동물이 볼륨 ${volume || 5}로 웁니다.`);
  }
}

// 자식 클래스
class Cat extends Animal {
  // JavaScript는 이름만 같으면 매개변수가 다르든 말든 덮어씁니다.
  makeSound(volume, isAngry) {
    if (isAngry) {
      console.log(`애옹!!!! (볼륨: ${volume})`);
    } else {
      // 필요 시 부모 메서드 호출 가능
      super.makeSound(volume);
      console.log("야옹~");
    }
  }
}

const myCat = new Cat();
myCat.makeSound(10, true);  // 출력: 애옹!!!! (볼륨: 10)
myCat.makeSound(3, false);  // 출력: 동물이 볼륨 3로 웁니다. \n 야옹~
```

JavaScript 환경에서는 함수(메서드) 선언 시 타입 정보가 없기 때문에 오버로딩 우회 기법(인자의 갯수나 `typeof` 확인)을 사용해야 객체 구분이 가능합니다. 이 점에서 오버라이딩 역시 오로지 "이름표(메서드명)" 하나로만 덮어쓰기가 결정됩니다.

---

## 4. 핵심 차이점 요약 (Java vs JavaScript)

| 구분                      | Java                                                     | JavaScript                                                   |
| ------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| **타입 검증**             | 매우 엄격함 (정적 타입)                                  | 느슨함 (동적 타입)                                           |
| **오버라이드 조건**       | 메서드 이름, 매개변수 개수/타입, 리턴타입 완벽 일치      | 메서드 **이름**만 동일하면 무조건 덮어씀                     |
| **명시적 표시**           | `@Override` 애노테이션 사용 권장 (컴파일러 체크용)       | 별도의 키워드나 데코레이터 없음                              |
| **오버로딩(Overloading)** | 기본 지원 (메서드 이름 같고 파라미터 다르면 다른 메서드) | 미지원 (인자 달라도 마지막 선언된 것으로 덮어씀)             |
| **다형성**                | 타입 캐스팅을 바탕으로 한 업캐스팅/다형성 구현           | 변수에 제약이 없어 자연스럽게 다형적 행위 가능 (Duck Typing) |

---

## 5. 결론

오버라이드는 부모의 기능을 자식 클래스에서 재정의한다는 큰 맥락에서는 두 언어가 동일합니다. 

하지만 **Java**는 컴파일러가 엄격하게 시그니처를 검사하여 개발자의 실수를 사전에 방지하는 반면, **JavaScript**는 프로토타입 체이닝을 활용해 이름만 같으면 유연하게 덮어쓰는 동적인 동작을 보여줍니다. (만약 JavaScript에서 Java와 같은 엄격함을 원한다면 **TypeScript**를 도입하는 것이 최선의 방법입니다.)

이러한 언어적 특성을 이해하고 코드를 작성한다면, 의도치 않은 오버라이딩으로 인한 버그를 줄이고 객체 지향의 장점을 제대로 활용할 수 있을 것입니다.
